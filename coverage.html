
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">rincon/api/api.go (100.0%)</option>
				
				<option value="file1">rincon/api/ping.go (100.0%)</option>
				
				<option value="file2">rincon/api/route.go (0.0%)</option>
				
				<option value="file3">rincon/api/service.go (100.0%)</option>
				
				<option value="file4">rincon/config/banner.go (100.0%)</option>
				
				<option value="file5">rincon/database/db.go (100.0%)</option>
				
				<option value="file6">rincon/database/local.go (100.0%)</option>
				
				<option value="file7">rincon/database/sql.go (96.0%)</option>
				
				<option value="file8">rincon/main.go (0.0%)</option>
				
				<option value="file9">rincon/model/route.go (100.0%)</option>
				
				<option value="file10">rincon/model/service.go (100.0%)</option>
				
				<option value="file11">rincon/service/balancer.go (0.0%)</option>
				
				<option value="file12">rincon/service/heartbeat.go (100.0%)</option>
				
				<option value="file13">rincon/service/route.go (21.8%)</option>
				
				<option value="file14">rincon/service/service.go (97.7%)</option>
				
				<option value="file15">rincon/utils/config.go (100.0%)</option>
				
				<option value="file16">rincon/utils/logger.go (100.0%)</option>
				
				<option value="file17">rincon/utils/service.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "encoding/base64"
        "rincon/config"
        "strings"
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
)

func SetupRouter() *gin.Engine <span class="cov7" title="6">{
        if config.Env == "PROD" </span><span class="cov7" title="6">{
                gin.SetMode(gin.ReleaseMode)
        }</span>
        <span class="cov7" title="6">r := gin.Default()
        r.Use(cors.New(cors.Config{
                AllowAllOrigins:  true,
                AllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"},
                AllowHeaders:     []string{"Origin", "Content-Length", "Content-Type", "Authorization"},
                MaxAge:           12 * time.Hour,
                AllowCredentials: true,
        }))
        r.Use(AuthMiddleware())
        return r</span>
}

func InitializeRoutes(router *gin.Engine) <span class="cov7" title="6">{
        rincon := router.Group("/rincon", func(c *gin.Context) </span>{<span class="cov9" title="10">}</span>)
        <span class="cov7" title="6">rincon.GET("/ping", Ping)
        rincon.GET("/services", GetAllServices)
        rincon.GET("/services/:name", GetService)
        rincon.DELETE("/services/:name", RemoveService)
        rincon.GET("/services/:name/routes", GetRoutesForService)
        rincon.POST("/services", CreateService)
        rincon.GET("/routes", GetAllRoutes)
        rincon.GET("/routes/:id", GetRoute)
        rincon.POST("/routes", CreateRoute)
        rincon.GET("/match", MatchRoute)</span>
}

func AuthMiddleware() gin.HandlerFunc <span class="cov7" title="6">{
        return func(c *gin.Context) </span><span class="cov10" title="12">{
                if c.Request.Method == "POST" || c.Request.Method == "PUT" || c.Request.Method == "DELETE" </span><span class="cov8" title="7">{
                        auth := strings.SplitN(c.Request.Header.Get("Authorization"), " ", 2)
                        if len(auth) != 2 || auth[0] != "Basic" </span><span class="cov1" title="1">{
                                c.AbortWithStatusJSON(401, gin.H{"message": "Request not authorized"})
                                return
                        }</span>
                        <span class="cov7" title="6">payload, _ := base64.StdEncoding.DecodeString(auth[1])
                        pair := strings.SplitN(string(payload), ":", 2)
                        if len(pair) != 2 || pair[0] != config.AuthUser || pair[1] != config.AuthPassword </span><span class="cov1" title="1">{
                                c.AbortWithStatusJSON(401, gin.H{"message": "Invalid credentials"})
                                return
                        }</span>
                }
                <span class="cov9" title="10">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "github.com/gin-gonic/gin"
        "rincon/config"
        "rincon/service"
)

func Ping(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(200, gin.H{
                "message":  "Rincon v" + config.Version + " is online!",
                "services": service.GetNumUniqueServices(),
                "routes":   service.GetNumRoutes(),
        })
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "fmt"
        "net/http"
        "rincon/model"
        "rincon/service"
        "strings"

        "github.com/gin-gonic/gin"
)

func GetAllRoutes(c *gin.Context) <span class="cov0" title="0">{
        result := service.GetAllRoutes()
        c.JSON(http.StatusOK, result)
}</span>

func GetRoute(c *gin.Context) <span class="cov0" title="0">{
        r := c.Query("route")
        r = strings.TrimPrefix(r, "/")
        r = strings.TrimSuffix(r, "/")
        m := c.Query("method")
        m = strings.ToUpper(m)
        s := c.Query("service")

        if r == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"message": "Route query is required"})
                return
        }</span>
        <span class="cov0" title="0">if s != "" </span><span class="cov0" title="0">{
                requestedRoute := service.GetRouteByRouteAndService(r, s)
                if requestedRoute.ID == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"message": fmt.Sprintf("No route /%s for service %s found", r, s)})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, requestedRoute)
                return</span>
        } else<span class="cov0" title="0"> if m != "" </span><span class="cov0" title="0">{
                requestedRoute := service.GetRouteByRouteAndMethod(r, m)
                if requestedRoute.ID == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"message": fmt.Sprintf("No route [%s] /%s found", m, r)})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, requestedRoute)
                return</span>
        } else<span class="cov0" title="0"> {
                c.JSON(http.StatusOK, service.GetRoutesByRoute(r))
                return
        }</span>
}

func GetRoutesForService(c *gin.Context) <span class="cov0" title="0">{
        result := service.GetRoutesByServiceName(c.Param("name"))
        c.JSON(http.StatusOK, result)
}</span>

func CreateRoute(c *gin.Context) <span class="cov0" title="0">{
        var input model.Route
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"message": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">err := service.CreateRoute(input)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"message": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, service.GetRouteByRouteAndService(input.Route, input.ServiceName))</span>
}

func MatchRoute(c *gin.Context) <span class="cov0" title="0">{
        route := c.Query("route")
        route = strings.TrimPrefix(route, "/")
        route = strings.TrimSuffix(route, "/")
        method := c.Query("method")
        method = strings.ToUpper(method)

        if route == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"message": "Route query is required"})
                return
        }</span>
        <span class="cov0" title="0">if method == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"message": "Method query is required"})
                return
        }</span>

        <span class="cov0" title="0">result := service.MatchRoute(route, method)
        if result.ID == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"message": fmt.Sprintf("No route [%s] /%s found", method, route)})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, result)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "github.com/gin-gonic/gin"
        "net/http"
        "rincon/model"
        "rincon/service"
        "strconv"
)

func GetAllServices(c *gin.Context) <span class="cov1" title="1">{
        result := service.GetAllServices()
        c.JSON(http.StatusOK, result)
}</span>

func GetService(c *gin.Context) <span class="cov10" title="3">{
        if i, err := strconv.Atoi(c.Param("name")); err == nil </span><span class="cov6" title="2">{
                // integer id passed
                result := service.GetServiceByID(i)
                if result.ID != i </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"message": "No service with id " + strconv.Itoa(i) + " found"})
                        return
                }</span>
                <span class="cov1" title="1">c.JSON(http.StatusOK, result)
                return</span>
        }
        // string name passed
        <span class="cov1" title="1">result := service.GetServicesByName(c.Param("name"))
        c.JSON(http.StatusOK, result)</span>
}

func CreateService(c *gin.Context) <span class="cov10" title="3">{
        var input model.Service
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"message": err.Error()})
                return
        }</span>
        <span class="cov6" title="2">createdService, err := service.CreateService(input)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"message": err.Error()})
                return
        }</span>
        <span class="cov1" title="1">c.JSON(http.StatusOK, createdService)</span>
}

func RemoveService(c *gin.Context) <span class="cov6" title="2">{
        if id, err := strconv.Atoi(c.Param("name")); err == nil </span><span class="cov1" title="1">{
                service.RemoveService(id)
                c.JSON(http.StatusOK, gin.H{"message": "Service with id " + strconv.Itoa(id) + " removed"})
                return
        }</span>
        <span class="cov1" title="1">c.JSON(http.StatusBadRequest, gin.H{"message": "Invalid service id"})</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import "github.com/fatih/color"

var Banner = `
██████╗ ██╗███╗   ██╗ ██████╗ ██████╗ ███╗   ██╗
██╔══██╗██║████╗  ██║██╔════╝██╔═══██╗████╗  ██║
██████╔╝██║██╔██╗ ██║██║     ██║   ██║██╔██╗ ██║
██╔══██╗██║██║╚██╗██║██║     ██║   ██║██║╚██╗██║
██║  ██║██║██║ ╚████║╚██████╗╚██████╔╝██║ ╚████║
╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝
`

func PrintStartupBanner() <span class="cov8" title="1">{
        banner := color.New(color.Bold, color.FgHiBlue).PrintlnFunc()
        banner(Banner)
        version := color.New(color.Bold, color.FgBlue).PrintlnFunc()
        version("Running v" + Version + " [ENV: " + Env + "]")
        println()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package database

import (
        "rincon/config"

        "gorm.io/gorm"
)

var DB *gorm.DB

var dbRetries = 0

func InitializeDB() <span class="cov10" title="7">{
        if config.StorageMode == "sql" </span><span class="cov8" title="5">{
                InitializeSQL()
        }</span> else<span class="cov4" title="2"> {
                InitializeLocal()
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package database

import "rincon/model"

var Local *LocalStore

type LocalStore struct {
        Services            []model.Service
        ServiceDependencies []model.ServiceDependency
        Routes              []model.Route
}

func InitializeLocal() <span class="cov10" title="6">{
        Local = &amp;LocalStore{
                Services:            make([]model.Service, 0),
                ServiceDependencies: make([]model.ServiceDependency, 0),
                Routes:              make([]model.Route, 0),
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package database

import (
        "fmt"
        "rincon/config"
        "rincon/model"
        "rincon/utils"
        "time"

        "gorm.io/driver/mysql"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

func InitializeSQL() <span class="cov10" title="10">{
        db, err := SelectDB()
        // if db == nil {
        //         utils.SugarLogger.Debugln("No valid database config, defaulting to local storage")
        //         config.StorageMode = "local"
        //         InitializeLocal()
        //         return
        // }
        if err != nil </span><span class="cov9" title="9">{
                if dbRetries &lt; 5 </span><span class="cov7" title="5">{
                        dbRetries++
                        utils.SugarLogger.Errorln("Failed to connect database, retrying in 5s... ")
                        time.Sleep(time.Second * 5)
                        InitializeSQL()
                }</span> else<span class="cov6" title="4"> {
                        utils.SugarLogger.Errorln("Failed to connect database after 5 attempts, defaulting to local storage")
                        config.StorageMode = "local"
                        InitializeLocal()
                        </span>return
                }
        } else {
                utils.SugarLogger.Infoln("Connected to database")
                err = db.AutoM</span><span class="cov0" title="0">igrate(&amp;model.Service{}, &amp;model.ServiceDependency{}, &amp;model.Route{})
                if err != nil {
                        </span>utils.SugarLogger.Errorln("AutoMigration failed", err)
                <span class="cov1" title="1">}
                utils.S</span>ugarLogger.Infoln("AutoMigration complete")
                DB = db
        }
}

func SelectDB() (*gorm.DB, error) {
</span>        if config.DatabaseDriver == "mysql" {
                </span>retur<span class="cov9" title="8">n ConnectMysql()
</span>        } else if config.DatabaseDriver == "postgres" {
                </span>return ConnectPostgres()
        <span class="cov8" title="6">}
</span>        return nil, fmt.Errorf("invalid database driver")
}

func ConnectPostgres() (*gorm.DB, error) {
        dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=disable TimeZone=UTC", config.DatabaseHost, config.DatabaseUser, config.DatabasePassword, config.DatabaseName, config.DatabasePort)
        </span>return gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
}

func ConnectMysql() (*gorm.DB, error) {
        dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=UTC", config.DatabaseUser, config.DatabasePassword, config.DatabaseHost, config.DatabasePort, config.DatabaseName)
        </span>return gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "rincon/api"
        "rincon/config"
        "rincon/database"
        "rincon/service"
        "rincon/utils"
)

func main() <span class="cov0" title="0">{
        config.PrintStartupBanner()
        utils.InitializeLogger()
        defer utils.Logger.Sync()

        utils.VerifyConfig()
        database.InitializeDB()
        service.RegisterSelf()
        service.InitializeHeartbeat()

        router := api.SetupRouter()
        api.InitializeRoutes(router)
        err := router.Run(":" + config.Port)
        if err != nil </span><span class="cov0" title="0">{
                utils.SugarLogger.Fatalln(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package model

import (
        "rincon/config"
        "slices"
        "strings"
        "time"
)

var validMethods = []string{"GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD", "*"}

type Route struct {
        ID          string    `json:"id" gorm:"primaryKey"`
        Route       string    `json:"route"`
        Method      string    `json:"method"`
        ServiceName string    `json:"service_name"`
        CreatedAt   time.Time `json:"created_at" gorm:"autoCreateTime;precision:6"`
}

func (Route) TableName() string <span class="cov1" title="1">{
        return config.DatabaseTablePrefix + "route"
}</span>

func (r *Route) IsMethodValid() bool <span class="cov10" title="15">{
        methods := strings.Split(r.Method, ",")
        for _, method := range methods </span><span class="cov10" title="15">{
                if !slices.Contains(validMethods, method) </span><span class="cov1" title="1">{
                        return false
                }</span>
        }
        <span class="cov9" title="14">return true</span>
}

type RouteNode struct {
        ID        string         `json:"id" gorm:"primaryKey"`
        Path      string         `json:"path"`
        Services  []RouteService `json:"services"`
        CreatedAt time.Time      `json:"created_at" gorm:"autoCreateTime;precision:6"`
}

type RouteService struct {
        ServiceName string `json:"service_name"`
        Method      string `json:"method"`
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package model

import (
        "rincon/config"
        "time"
)

type Service struct {
        ID          int       `json:"id" gorm:"primaryKey"`
        Name        string    `json:"name"`
        Version     string    `json:"version"`
        Endpoint    string    `json:"endpoint" gorm:"unique"`
        HealthCheck string    `json:"health_check"`
        UpdatedAt   time.Time `json:"updated_at" gorm:"autoUpdateTime;precision:6"`
        CreatedAt   time.Time `json:"created_at" gorm:"autoCreateTime;precision:6"`
}

func (Service) TableName() string <span class="cov8" title="1">{
        return config.DatabaseTablePrefix + "service"
}</span>

type ServiceDependency struct {
        ParentID  string    `json:"parent_id" gorm:"primaryKey"`
        ChildID   string    `json:"child_id" gorm:"primaryKey"`
        UpdatedAt time.Time `json:"updated_at" gorm:"autoUpdateTime;precision:6"`
        CreatedAt time.Time `json:"created_at" gorm:"autoCreateTime;precision:6"`
}

func (ServiceDependency) TableName() string <span class="cov8" title="1">{
        return config.DatabaseTablePrefix + "service_dependency"
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package service

import (
        "math/rand"
        "rincon/model"
)

func LoadBalance(serviceName string, balancer string) model.Service <span class="cov0" title="0">{
        var service model.Service
        services := GetServicesByName(serviceName)
        if len(services) == 0 </span><span class="cov0" title="0">{
                return service
        }</span>
        <span class="cov0" title="0">if balancer == "random" </span><span class="cov0" title="0">{
                service = RandomSelector(services)
        }</span>
        <span class="cov0" title="0">return service</span>
}

func RandomSelector(services []model.Service) model.Service <span class="cov0" title="0">{
        return services[rand.Intn(len(services))]
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package service

import (
        "rincon/config"
        "rincon/utils"
        "strconv"
        "time"

        "github.com/go-co-op/gocron/v2"
        "github.com/go-resty/resty/v2"
)

func InitializeHeartbeat() <span class="cov10" title="3">{
        s, _ := gocron.NewScheduler()
        interval, err := strconv.Atoi(config.HeartbeatInterval)
        if err != nil </span><span class="cov10" title="3">{
                utils.SugarLogger.Debugln("HEARTBEAT_INTERVAL is invalid, defaulting to 10")
                interval = 10
        }</span>
        <span class="cov10" title="3">if config.HeartbeatType == "client" </span><span class="cov1" title="1">{
                j, _ := s.NewJob(
                        gocron.DurationJob(time.Duration(interval)*time.Second),
                        gocron.NewTask(ClientHeartbeat, interval),
                )
                utils.SugarLogger.Infof("Job ID: %d", j.ID)
                s.Start()
        }</span> else<span class="cov6" title="2"> {
                j, _ := s.NewJob(
                        gocron.DurationJob(time.Duration(interval)*time.Second),
                        gocron.NewTask(ServerHeartbeat, interval),
                )
                utils.SugarLogger.Infof("Job ID: %d", j.ID)
                s.Start()
        }</span>
}

func ServerHeartbeat(interval int) <span class="cov1" title="1">{
        client := resty.New()
        for _, s := range GetAllServices() </span><span class="cov10" title="3">{
                resp, err := client.R().Get(s.HealthCheck)
                if err != nil </span><span class="cov1" title="1">{
                        utils.SugarLogger.Errorf("Error pinging %s (%d): %v", s.Name, s.ID, err)
                        RemoveService(s.ID)
                }</span> else<span class="cov6" title="2"> {
                        if resp.StatusCode() &gt;= 200 &amp;&amp; resp.StatusCode() &lt; 300 </span><span class="cov1" title="1">{
                                utils.SugarLogger.Infof("Pinged %s (%d) in %dms", s.Name, s.ID, resp.Time().Milliseconds())
                        }</span> else<span class="cov1" title="1"> {
                                utils.SugarLogger.Errorf("Error pinging %s (%d): %v", s.Name, s.ID, resp)
                                RemoveService(s.ID)
                        }</span>
                }
        }
}

func ClientHeartbeat(interval int) <span class="cov1" title="1">{
        for _, s := range GetAllServices() </span><span class="cov6" title="2">{
                delta := time.Since(s.UpdatedAt).Milliseconds()
                utils.SugarLogger.Infof("Last %s (%d) ping was %dms ago", s.Name, s.ID, delta)
                if delta &gt; int64((interval+1)*1000) &amp;&amp; s.Name != "rincon" </span><span class="cov1" title="1">{
                        utils.SugarLogger.Errorf("Service %s (%d) registration expired!", s.Name, s.ID)
                        RemoveService(s.ID)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package service

import (
        "fmt"
        "rincon/config"
        "rincon/database"
        "rincon/model"
        "rincon/utils"
        "strings"
        "time"
)

func GetAllRoutes() []model.Route <span class="cov0" title="0">{
        routes := make([]model.Route, 0)
        if config.StorageMode == "sql" </span><span class="cov0" title="0">{
                database.DB.Find(&amp;routes)
        }</span> else<span class="cov0" title="0"> {
                routes = database.Local.Routes
        }</span>
        <span class="cov0" title="0">return routes</span>
}

func GetNumRoutes() int <span class="cov0" title="0">{
        if config.StorageMode == "sql" </span><span class="cov0" title="0">{
                var count int64
                database.DB.Model(&amp;model.Route{}).Count(&amp;count)
                return int(count)

        }</span> else<span class="cov0" title="0"> {
                return len(database.Local.Routes)
        }</span>
}

func GetRoutesByRoute(route string) []model.Route <span class="cov8" title="16">{
        routes := make([]model.Route, 0)
        if config.StorageMode == "sql" </span><span class="cov0" title="0">{
                database.DB.Where("route = ?", route).Find(&amp;routes)
        }</span> else<span class="cov8" title="16"> {
                for _, r := range database.Local.Routes </span><span class="cov10" title="32">{
                        if r.Route == route </span><span class="cov2" title="2">{
                                routes = append(routes, r)
                        }</span>
                }
        }
        <span class="cov8" title="16">return routes</span>
}

func GetRoutesByServiceName(name string) []model.Route <span class="cov0" title="0">{
        name = utils.NormalizeName(name)
        routes := make([]model.Route, 0)
        if config.StorageMode == "sql" </span><span class="cov0" title="0">{
                database.DB.Where("service_name = ?", name).Find(&amp;routes)
        }</span> else<span class="cov0" title="0"> {
                for _, r := range database.Local.Routes </span><span class="cov0" title="0">{
                        if r.ServiceName == name </span><span class="cov0" title="0">{
                                routes = append(routes, r)
                        }</span>
                }
        }
        <span class="cov0" title="0">return routes</span>
}

func GetRouteByRouteAndMethod(route string, method string) model.Route <span class="cov0" title="0">{
        routes := GetRoutesByRoute(route)
        for _, r := range routes </span><span class="cov0" title="0">{
                if strings.Contains(r.Method, method) || strings.Contains(r.Method, "*") </span><span class="cov0" title="0">{
                        return r
                }</span>
        }
        <span class="cov0" title="0">return model.Route{}</span>
}

func GetRouteByRouteAndService(route string, service string) model.Route <span class="cov6" title="8">{
        routes := GetRoutesByRoute(route)
        for _, r := range routes </span><span class="cov1" title="1">{
                if r.ServiceName == service </span><span class="cov1" title="1">{
                        return r
                }</span>
        }
        <span class="cov6" title="7">return model.Route{}</span>
}

func CreateRoute(route model.Route) error <span class="cov7" title="12">{
        if route.Route == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("route cannot be empty")
        }</span> else<span class="cov7" title="11"> if route.ServiceName == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("service name cannot be empty")
        }</span> else<span class="cov6" title="10"> if strings.HasSuffix(route.Route, "/") </span><span class="cov1" title="1">{
                return fmt.Errorf("route cannot end with a slash")
        }</span> else<span class="cov6" title="9"> if !route.IsMethodValid() </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid method %s", route.Method)
        }</span>
        <span class="cov6" title="8">route.ID = fmt.Sprintf("%s-[%s]", route.Route, route.Method)
        route.ServiceName = utils.NormalizeName(route.ServiceName)
        route.CreatedAt = time.Now()

        if IsRouteMethodOverlap(route) </span><span class="cov0" title="0">{
                if config.OverwriteRoutes == "true" </span><span class="cov0" title="0">{
                        DeleteRoute(route.ID)
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("route with id %s overlaps with an existing route", route.ID)
                }</span>
        } else<span class="cov6" title="8"> if existingRoute := GetRouteByRouteAndService(route.Route, route.ServiceName); existingRoute.ID != "" </span><span class="cov1" title="1">{
                utils.SugarLogger.Debugf("route with route %s for service %s already exists", route.Route, route.ServiceName)
                if existingRoute.Method != route.Method </span><span class="cov0" title="0">{
                        utils.SugarLogger.Debugf("route has different method, replacing existing route")
                        DeleteRoute(existingRoute.ID)
                }</span>
        }

        <span class="cov6" title="8">if config.StorageMode == "sql" </span><span class="cov0" title="0">{
                database.DB.Create(&amp;route)
        }</span> else<span class="cov6" title="8"> {
                database.Local.Routes = append(database.Local.Routes, route)
        }</span>
        <span class="cov6" title="8">utils.SugarLogger.Infof("route with id %s registered for service %s", route.ID, route.ServiceName)
        return nil</span>
}

func IsRouteMethodOverlap(route model.Route) bool <span class="cov6" title="8">{
        routes := GetRoutesByRoute(route.Route)
        takenMethods := make(map[string]string)
        for _, r := range routes </span><span class="cov1" title="1">{
                for _, m := range strings.Split(r.Method, ",") </span><span class="cov1" title="1">{
                        takenMethods[m] = r.ServiceName
                        if m == "*" </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov6" title="8">for _, m := range strings.Split(route.Method, ",") </span><span class="cov6" title="8">{
                if takenMethods[m] != "" &amp;&amp; takenMethods[m] != route.ServiceName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov6" title="8">return false</span>
}

func DeleteRoute(id string) <span class="cov0" title="0">{
        if config.StorageMode == "sql" </span><span class="cov0" title="0">{
                database.DB.Where("route = ?", id).Delete(&amp;model.Route{})
        }</span> else<span class="cov0" title="0"> {
                for i, r := range database.Local.Routes </span><span class="cov0" title="0">{
                        if r.Route == id </span><span class="cov0" title="0">{
                                database.Local.Routes = append(database.Local.Routes[:i], database.Local.Routes[i+1:]...)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">utils.SugarLogger.Infof("route with id %s deleted", id)</span>
}

func MatchRoute(route string, method string) model.Service <span class="cov0" title="0">{
        if utils.SugarLogger.Level().String() == "debug" </span><span class="cov0" title="0">{
                PrintRouteGraph()
        }</span>
        <span class="cov0" title="0">var service model.Service
        graph := GetRouteGraph()
        utils.SugarLogger.Debugf("Matching route  /" + route)
        matchedRoute := TraverseGraph("", route, method, graph)
        if matchedRoute == "" </span><span class="cov0" title="0">{
                utils.SugarLogger.Errorf("No route found for /%s", route)
                return service
        }</span>
        <span class="cov0" title="0">utils.SugarLogger.Debugf("Matched to " + matchedRoute)
        for _, r := range GetAllRoutes() </span><span class="cov0" title="0">{
                if r.Route == matchedRoute &amp;&amp; (strings.Contains(r.Method, method) || strings.Contains(r.Method, "*")) </span><span class="cov0" title="0">{
                        service.Name = r.ServiceName
                        break</span>
                }
        }
        <span class="cov0" title="0">if service.Name == "" </span><span class="cov0" title="0">{
                utils.SugarLogger.Errorf("No service found for route /%s", route)
                go DeleteRoute(matchedRoute)
                return service
        }</span>
        <span class="cov0" title="0">service = LoadBalance(service.Name, "random")
        if service.ID == 0 </span><span class="cov0" title="0">{
                utils.SugarLogger.Infoln("No eligible service instance found for" + service.Name)
        }</span> else<span class="cov0" title="0"> {
                utils.SugarLogger.Infof("Matched route /%s to %s for service %s (%d)", route, matchedRoute, service.Name, service.ID)
        }</span>
        <span class="cov0" title="0">return service</span>
}

func TraverseGraph(path string, route string, method string, graph map[string][]model.RouteNode) string <span class="cov0" title="0">{
        currPathCount := strings.Count(path, "/")
        routeSlugCount := strings.Count("/"+route, "/")
        lastSlug := strings.Split(path, "/")[len(strings.Split(path, "/"))-1]
        pathWithoutLastSlug := strings.TrimSuffix(path, "/"+lastSlug)

        utils.SugarLogger.Debugf("Traversing graph with path \"%s\" and route \"/%s\"", path, route)

        if pathWithoutLastSlug == "" </span><span class="cov0" title="0">{
                pathWithoutLastSlug = "/"
        }</span>
        <span class="cov0" title="0">cindex := HasChildPath(lastSlug, graph[pathWithoutLastSlug])
        if lastSlug != "" &amp;&amp; cindex == -1 </span><span class="cov0" title="0">{
                utils.SugarLogger.Debugf("Child path \"%s\" does not exist", lastSlug)
                return ""
        }</span>
        <span class="cov0" title="0">if lastSlug == "**" &amp;&amp; CanRouteHandleMethod(graph[pathWithoutLastSlug][cindex], method) </span><span class="cov0" title="0">{
                utils.SugarLogger.Debugf("Found all path wildcard (**)")
                return path
        }</span>
        <span class="cov0" title="0">utils.SugarLogger.Debugf("Child path \"%s\" exists", lastSlug)

        if currPathCount == routeSlugCount </span><span class="cov0" title="0">{
                utils.SugarLogger.Debugf("Reached end of route")
                if CanRouteHandleMethod(graph[pathWithoutLastSlug][cindex], method) </span><span class="cov0" title="0">{
                        utils.SugarLogger.Debugf("Route can handle method %s", method)
                        return path
                }</span> else<span class="cov0" title="0"> {
                        utils.SugarLogger.Debugf("Route cannot handle method %s", method)
                        return ""
                }</span>
        }

        <span class="cov0" title="0">nextSlug := strings.Split("/"+route, "/")[currPathCount+1]
        slugBranch := TraverseGraph(path+"/"+nextSlug, route, method, graph)
        if slugBranch != "" </span><span class="cov0" title="0">{
                return slugBranch
        }</span>
        <span class="cov0" title="0">anyBranch := TraverseGraph(path+"/*", route, method, graph)
        if anyBranch != "" </span><span class="cov0" title="0">{
                return anyBranch
        }</span>
        <span class="cov0" title="0">allBranch := TraverseGraph(path+"/**", route, method, graph)
        if allBranch != "" </span><span class="cov0" title="0">{
                return allBranch
        }</span>

        <span class="cov0" title="0">return ""</span>
}

func HasChildPath(path string, children []model.RouteNode) int <span class="cov0" title="0">{
        for i, c := range children </span><span class="cov0" title="0">{
                if c.Path == path </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func CanRouteHandleMethod(route model.RouteNode, method string) bool <span class="cov0" title="0">{
        for _, s := range route.Services </span><span class="cov0" title="0">{
                if strings.Contains(s.Method, method) || strings.Contains(s.Method, "*") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func GetRouteGraph() map[string][]model.RouteNode <span class="cov0" title="0">{
        children := make(map[string][]model.RouteNode)
        routes := GetAllRoutes()
        for _, r := range routes </span><span class="cov0" title="0">{
                slugs := strings.Split(r.Route, "/")
                parent := ""
                for i := 0; i &lt; len(slugs); i++ </span><span class="cov0" title="0">{
                        if slugs[i] != "" </span><span class="cov0" title="0">{
                                if parent == "" </span><span class="cov0" title="0">{
                                        parent = "/"
                                }</span>
                                <span class="cov0" title="0">if _, exists := children[parent]; !exists </span><span class="cov0" title="0">{
                                        children[parent] = make([]model.RouteNode, 0)
                                }</span>
                                <span class="cov0" title="0">endpoint := false
                                if i == len(slugs)-1 </span><span class="cov0" title="0">{
                                        endpoint = true
                                }</span>
                                <span class="cov0" title="0">if index := HasChildPath(slugs[i], children[parent]); index != -1 </span><span class="cov0" title="0">{
                                        if endpoint </span><span class="cov0" title="0">{
                                                children[parent][index].Services = append(children[parent][index].Services, model.RouteService{
                                                        ServiceName: r.ServiceName,
                                                        Method:      r.Method,
                                                })
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        if endpoint </span><span class="cov0" title="0">{
                                                children[parent] = append(children[parent], model.RouteNode{
                                                        ID:        parent + "/" + slugs[i],
                                                        Path:      slugs[i],
                                                        Services:  []model.RouteService{{ServiceName: r.ServiceName, Method: r.Method}},
                                                        CreatedAt: time.Now(),
                                                })
                                        }</span> else<span class="cov0" title="0"> {
                                                children[parent] = append(children[parent], model.RouteNode{
                                                        ID:        parent + "/" + slugs[i],
                                                        Path:      slugs[i],
                                                        Services:  []model.RouteService{},
                                                        CreatedAt: time.Now(),
                                                })
                                        }</span>
                                }
                                <span class="cov0" title="0">if parent == "/" </span><span class="cov0" title="0">{
                                        parent += slugs[i]
                                }</span> else<span class="cov0" title="0"> {
                                        parent += "/" + slugs[i]
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return children</span>
}

func PrintRouteGraph() <span class="cov0" title="0">{
        println("======= ROUTE GRAPH =======")
        graph := GetRouteGraph()
        for k, v := range graph </span><span class="cov0" title="0">{
                println(k)
                for _, n := range v </span><span class="cov0" title="0">{
                        println("   -&gt; " + n.Path + " (" + PrintRouteServices(n.Services) + ")")
                }</span>
        }
        <span class="cov0" title="0">println("===========================")</span>
}

func PrintRouteServices(rs []model.RouteService) string <span class="cov0" title="0">{
        s := ""
        for i, r := range rs </span><span class="cov0" title="0">{
                s += fmt.Sprintf("[%s] %s", r.Method, r.ServiceName)
                if i != len(rs)-1 </span><span class="cov0" title="0">{
                        s += ", "
                }</span>
        }
        <span class="cov0" title="0">return s</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package service

import (
        "fmt"
        "rincon/config"
        "rincon/database"
        "rincon/model"
        "rincon/utils"
        "time"
)

func GetAllServices() []model.Service <span class="cov5" title="6">{
        services := make([]model.Service, 0)
        if config.StorageMode == "sql" </span><span class="cov4" title="4">{
                database.DB.Find(&amp;services)
        }</span> else<span class="cov2" title="2"> {
                services = database.Local.Services
        }</span>
        <span class="cov5" title="6">return services</span>
}

func GetNumServices() int <span class="cov2" title="2">{
        if config.StorageMode == "sql" </span><span class="cov1" title="1">{
                var count int64
                database.DB.Model(&amp;model.Service{}).Count(&amp;count)
                return int(count)
        }</span> else<span class="cov1" title="1"> {
                return len(database.Local.Services)
        }</span>
}

func GetNumUniqueServices() int <span class="cov2" title="2">{
        if config.StorageMode == "sql" </span><span class="cov1" title="1">{
                var services []model.Service
                database.DB.Distinct("name").Find(&amp;services)
                return len(services)
        }</span> else<span class="cov1" title="1"> {
                unique := make(map[string]bool)
                for _, s := range database.Local.Services </span><span class="cov2" title="2">{
                        unique[s.Name] = true
                }</span>
                <span class="cov1" title="1">return len(unique)</span>
        }
}

func GetServiceByID(id int) model.Service <span class="cov2" title="2">{
        var service model.Service
        if config.StorageMode == "sql" </span><span class="cov1" title="1">{
                database.DB.First(&amp;service, id)
        }</span> else<span class="cov1" title="1"> {
                for _, s := range database.Local.Services </span><span class="cov2" title="2">{
                        if s.ID == id </span><span class="cov1" title="1">{
                                service = s
                                break</span>
                        }
                }
        }
        <span class="cov2" title="2">return service</span>
}

func GetServicesByName(name string) []model.Service <span class="cov2" title="2">{
        services := make([]model.Service, 0)
        if config.StorageMode == "sql" </span><span class="cov1" title="1">{
                database.DB.Where("name = ?", name).Find(&amp;services)
        }</span> else<span class="cov1" title="1"> {
                for _, s := range database.Local.Services </span><span class="cov2" title="2">{
                        if s.Name == name </span><span class="cov2" title="2">{
                                services = append(services, s)
                        }</span>
                }
        }
        <span class="cov2" title="2">return services</span>
}

func GetServiceByEndpoint(endpoint string) model.Service <span class="cov10" title="38">{
        var service model.Service
        if config.StorageMode == "sql" </span><span class="cov8" title="24">{
                database.DB.Where("endpoint = ?", endpoint).First(&amp;service)
        }</span> else<span class="cov7" title="14"> {
                for _, s := range database.Local.Services </span><span class="cov6" title="11">{
                        if s.Endpoint == endpoint </span><span class="cov6" title="9">{
                                service = s
                                break</span>
                        }
                }
        }
        <span class="cov10" title="38">return service</span>
}

func CreateService(service model.Service) (model.Service, error) <span class="cov8" title="23">{
        if service.Name == "" </span><span class="cov1" title="1">{
                return model.Service{}, fmt.Errorf("service name cannot be empty")
        }</span> else<span class="cov8" title="22"> if service.Version == "" </span><span class="cov1" title="1">{
                return model.Service{}, fmt.Errorf("service version cannot be empty")
        }</span> else<span class="cov8" title="21"> if service.Endpoint == "" </span><span class="cov1" title="1">{
                return model.Service{}, fmt.Errorf("service endpoint cannot be empty")
        }</span> else<span class="cov8" title="20"> if service.HealthCheck == "" </span><span class="cov1" title="1">{
                return model.Service{}, fmt.Errorf("service health check cannot be empty")
        }</span>
        <span class="cov8" title="19">service.Name = utils.NormalizeName(service.Name)
        existing := GetServiceByEndpoint(service.Endpoint)
        if config.StorageMode == "sql" </span><span class="cov7" title="12">{
                if existing.Endpoint != "" </span><span class="cov4" title="4">{
                        service.ID = existing.ID
                        database.DB.Model(&amp;service).Where("endpoint = ?", service.Endpoint).Updates(service)
                }</span> else<span class="cov6" title="8"> {
                        service.ID = utils.GenerateID(0)
                        database.DB.Create(&amp;service)
                }</span>
        } else<span class="cov5" title="7"> {
                if existing.Endpoint != "" </span><span class="cov2" title="2">{
                        service.ID = existing.ID
                        service.CreatedAt = existing.CreatedAt
                        service.UpdatedAt = time.Now()
                        for i, s := range database.Local.Services </span><span class="cov2" title="2">{
                                if s.ID == existing.ID </span><span class="cov2" title="2">{
                                        database.Local.Services[i] = service
                                        break</span>
                                }
                        }
                } else<span class="cov4" title="5"> {
                        service.ID = utils.GenerateID(0)
                        service.UpdatedAt = time.Now()
                        service.CreatedAt = time.Now()
                        database.Local.Services = append(database.Local.Services, service)
                }</span>
        }
        <span class="cov8" title="19">newService := GetServiceByEndpoint(service.Endpoint)
        utils.SugarLogger.Infof("registered service (%d) %s at %s", newService.ID, newService.Name, newService.Endpoint)
        return newService, nil</span>
}

func RemoveService(id int) <span class="cov4" title="5">{
        if config.StorageMode == "sql" </span><span class="cov4" title="4">{
                database.DB.Delete(&amp;model.Service{}, id)
                return
        }</span> else<span class="cov1" title="1"> {
                for i, s := range database.Local.Services </span><span class="cov1" title="1">{
                        if s.ID == id </span><span class="cov1" title="1">{
                                database.Local.Services = append(database.Local.Services[:i], database.Local.Services[i+1:]...)
                                break</span>
                        }
                }
        }
}

func RegisterSelf() <span class="cov1" title="1">{
        service := model.Service{
                Name:        "Rincon",
                Version:     config.Version,
                Endpoint:    "http://localhost:" + config.Port,
                HealthCheck: "http://localhost:" + config.Port + "/rincon/ping",
                UpdatedAt:   time.Now(),
                CreatedAt:   time.Now(),
        }
        _, err := CreateService(service)
        if err != nil </span><span class="cov0" title="0">{
                utils.SugarLogger.Errorf("Error when creating service: %v", err)
        }</span>
        <span class="cov1" title="1">for _, route := range []string{"/rincon/ping", "/rincon/services", "/rincon/services/**", "/rincon/routes", "/rincon/routes/**", "/rincon/match"} </span><span class="cov5" title="6">{
                err := CreateRoute(model.Route{
                        Route:       route,
                        ServiceName: "Rincon",
                        Method:      "*",
                        CreatedAt:   time.Now(),
                })
                if err != nil </span><span class="cov0" title="0">{
                        utils.SugarLogger.Errorf("Error when creating route: %v", err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package utils

import (
        "rincon/config"
        "strconv"
)

func VerifyConfig() <span class="cov10" title="5">{
        if config.Env == "" </span><span class="cov1" title="1">{
                config.Env = "PROD"
                SugarLogger.Debugln("ENV is not set, defaulting to PROD")
        }</span>
        <span class="cov10" title="5">if config.Port == "" </span><span class="cov1" title="1">{
                config.Port = "10311"
                SugarLogger.Debugln("PORT is not set, defaulting to 10311")
        }</span>
        <span class="cov10" title="5">if config.AuthUser == "" </span><span class="cov1" title="1">{
                config.AuthUser = "admin"
                SugarLogger.Debugln("AUTH_USER is not set, defaulting to admin")
        }</span>
        <span class="cov10" title="5">if config.AuthPassword == "" </span><span class="cov1" title="1">{
                config.AuthPassword = "admin"
                SugarLogger.Debugln("AUTH_PASSWORD is not set, defaulting to admin")
        }</span>

        <span class="cov10" title="5">if config.ServiceIDLength == "" </span><span class="cov1" title="1">{
                config.ServiceIDLength = "6"
                SugarLogger.Debugln("SERVICE_ID_LENGTH is not set, defaulting to 6")
        }</span>
        <span class="cov10" title="5">if i, err := strconv.Atoi(config.ServiceIDLength); i &lt; 4 || err != nil </span><span class="cov1" title="1">{
                config.ServiceIDLength = "4"
                SugarLogger.Debugln("SERVICE_ID_LENGTH is less than 4, defaulting to 4")
        }</span>
        <span class="cov10" title="5">if config.StorageMode == "sql" </span><span class="cov1" title="1">{
                verifySql()
        }</span> else<span class="cov8" title="4"> if config.StorageMode == "redis" </span>{<span class="cov1" title="1">

        }</span> else<span class="cov7" title="3"> if config.StorageMode == "redis+sql" </span><span class="cov1" title="1">{
                verifySql()
        }</span> else<span class="cov4" title="2"> {
                config.StorageMode = "local"
                SugarLogger.Infoln("STORAGE_MODE is not set, defaulting to local")
        }</span>
        <span class="cov10" title="5">if config.OverwriteRoutes == "" </span><span class="cov1" title="1">{
                config.OverwriteRoutes = "true"
                SugarLogger.Debugln("OVERWRITE_ROUTES is not set, defaulting to true")
        }</span>
        <span class="cov10" title="5">if config.HeartbeatType == "" </span><span class="cov1" title="1">{
                config.HeartbeatType = "server"
                SugarLogger.Debugln("HEARTBEAT_TYPE is not set, defaulting to server")
        }</span>
        <span class="cov10" title="5">if config.HeartbeatInterval == "" </span><span class="cov1" title="1">{
                config.HeartbeatInterval = "10"
                SugarLogger.Debugln("HEARTBEAT_INTERVAL is not set, defaulting to 10")
        }</span>
        <span class="cov10" title="5">if config.DatabaseTablePrefix == "" </span><span class="cov1" title="1">{
                config.DatabaseTablePrefix = "rin_"
                SugarLogger.Debugln("DB_TABLE_PREFIX is not set, defaulting to rin_")
        }</span>
}

func verifySql() <span class="cov7" title="3">{
        if config.DatabaseDriver == "" </span><span class="cov1" title="1">{
                SugarLogger.Errorln("STORAGE_MODE is set to " + config.StorageMode + " but DB_DRIVER is not set")
        }</span>
        <span class="cov7" title="3">if config.DatabaseHost == "" </span><span class="cov1" title="1">{
                SugarLogger.Errorln("STORAGE_MODE is set to " + config.StorageMode + " but DB_HOST is not set")
        }</span>
        <span class="cov7" title="3">if config.DatabasePort == "" </span><span class="cov1" title="1">{
                SugarLogger.Errorln("STORAGE_MODE is set to " + config.StorageMode + " but DB_PORT is not set")
        }</span>
        <span class="cov7" title="3">if config.DatabaseName == "" </span><span class="cov1" title="1">{
                SugarLogger.Errorln("STORAGE_MODE is set to " + config.StorageMode + " but DB_NAME is not set")
        }</span>
        <span class="cov7" title="3">if config.DatabaseUser == "" </span><span class="cov1" title="1">{
                SugarLogger.Errorln("STORAGE_MODE is set to " + config.StorageMode + " but DB_USER is not set")
        }</span>
        <span class="cov7" title="3">if config.DatabasePassword == "" </span><span class="cov1" title="1">{
                SugarLogger.Errorln("STORAGE_MODE is set to " + config.StorageMode + " but DB_PASSWORD is not set")
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package utils

import (
        "go.uber.org/zap"
        "rincon/config"
)

var Logger *zap.Logger
var SugarLogger *zap.SugaredLogger

func InitializeLogger() <span class="cov10" title="7">{
        Logger = zap.Must(zap.NewProduction())
        if config.Env == "DEV" </span><span class="cov1" title="1">{
                Logger = zap.Must(zap.NewDevelopment())
        }</span>
        <span class="cov10" title="7">SugarLogger = Logger.Sugar()</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package utils

import (
        "math/rand"
        "rincon/config"
        "strconv"
        "strings"
)

func GenerateID(length int) int <span class="cov3" title="2">{
        if length == 0 </span><span class="cov1" title="1">{
                length, _ = strconv.Atoi(config.ServiceIDLength)
        }</span>
        <span class="cov3" title="2">var id string
        for i := 0; i &lt; length; i++ </span><span class="cov10" title="16">{
                if i == 0 </span><span class="cov3" title="2">{
                        id += strconv.Itoa(rand.Intn(9) + 1)
                }</span> else<span class="cov9" title="14"> {
                        id += strconv.Itoa(rand.Intn(10))
                }</span>
        }
        <span class="cov3" title="2">idInt, _ := strconv.Atoi(id)
        return idInt</span>
}

func NormalizeName(name string) string <span class="cov1" title="1">{
        return strings.ToLower(strings.ReplaceAll(name, " ", "_"))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
